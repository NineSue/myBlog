---
title: 'I/O模型'
author: '安'
description: '瞅瞅I/O模型做的那些事儿'
publishDate: '2025-08-28'
updatedDate: '2025-08-28'
tags:
  - 进程间通信
  - 网络
  - 内核
  - 操作系统
language: 'Chinese'
draft: false
heroImage: { src: './0.jpg', color: '#690600' }
---
## IO产生的原因
试想一下，两台机器通信，首先A会将消息丢到缓存区，然后缓冲区通过网络传输，丢到B的缓冲区，B再从自己的缓冲区读取，这是我们的基本。

## 几个概念
当看到IO相关概念，会看见几个词，同步异步，还有阻塞非阻塞，在起初我把同步和非阻塞连在一起理解，但并不是这样。
- 同步：就是自己一个人，没人通知我，我自食其力。
- 异步：有人帮我，代理人有结果通知我。
- 阻塞：我一直在等数据，对方不给我一丝丝提示，我就一直苦苦等待。
- 非阻塞：对方给予我提示，有数据我就读取，没数据对方便告诉我甭等了，咱们撤退。

或者我们换一个角度记忆会更清晰一些，`同步、异步`是针对`进程、线程`或者说是针对`用户态`和`内核态`的交互状态，而`阻塞、非阻塞`是针对`函数的`

## 阻塞IO
流程：
1. 用户态向内核态发起读取数据
2. 准备数据的时候用户态进程阻塞
3. 准备完成复制到用户态
4. 复制完成后，返回成功提示

## 非阻塞IO
流程：
1. 用户态向内核态发起读取数据
2. 有数据包就绪就复制到用户态且返回成功码，否则还是返回错误码，过段时间再来询问

## IO复用模型
以上情况，对于但线程当然是极好的，但是在并发情况，每次请求都对应一个线程，倘若有海量的信息发送或者接受，系统调用的次数和线程资源的浪费会造成大量操作冗余，于是就引出了复用技术，令某个线程监听多个FD，让线程池的线程去进行对应操作。

## 信号驱动IO模型
IO复用模型采用线程主动轮训监听，而信号驱动则是与线程建立信号联系，数据准备好的时候，发送可读信号，然后才去读。

## 异步IO
可以发现以上两种模型，会去发起两段请求，一问准备好了没，二把数据拿过来。所以便出现了这种模型，为了一劳永逸，用户态发起请求，内核会建立信号连接，当数据就绪，内核态会主动推送过来，这样就通过一次请求把`状态询问`和`数据拷贝`都完成了。
