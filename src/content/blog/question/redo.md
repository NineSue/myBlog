---
title: '佬们问题记录本'
author: '安'
description: '学长在群里问的问题及其回答，咱偷偷记下来'
publishDate: '2025-08-29'
updatedDate: '2025-08-29'
tags:
  - java
  - 反射
language: 'Chinese'
draft: false
heroImage: { src: './0.jpg', color: '#004D17' }
---
## Q
1. [mysql为啥要搞一个redologbuffer， 而不直接把redolog文件通过文件映射到用户态直接写？](#mysql-为什么要有-redo-log-buffer)
2. [询问各位佬一个问题，反射调方法和正常调方法有什么区别？](#java-反射调用和正常调用有什么区别)
3. [raft和zab的区别是什么](#raft和zab的区别)

---
## A

### MySQL 为什么要有 redo log buffer？
MySQL 之所以要有 redo log buffer，本质上是 **数据库不能把日志写盘这件事交给内核**。  
“文件映射到用户态”（即mmap）虽能避免内核态/用户态拷贝，但InnoDB设计redo log buffer的核心目的是**平衡性能、事务一致性与崩溃可靠性**，直接用mmap无法满足需求：

1. **减少磁盘IO次数：批量刷盘优化** redo log buffer会暂存多个事务的日志，积累到一定量（如 buffer 用满1/2、事务提交）后批量刷盘，大幅减少单次小日志的IO次数；若直接写mmap，每次日志写入可能触发OS的“页刷新”，IO频率会显著升高。

2. **保障事务一致性：精准控制提交时机** redo log需配合“两阶段提交”（Prepare→Commit）：未提交事务的日志仅存于buffer，仅当事务确认提交时，才按innodb_flush_log_at_trx_commit策略刷盘；若直接写mmap，未提交的日志可能已进入OS缓存，崩溃时OS可能误刷盘，导致数据不一致。

3. **灵活的内存与刷盘策略** buffer由InnoDB自主管理（大小可通过innodb_log_buffer_size配置，刷盘策略可按需选择0/1/2）；而mmap依赖OS内存管理，可能因OS页置换、缓存回收导致日志页失效，还无法自定义刷盘逻辑，影响崩溃恢复的可靠性。

---

### Java 反射调用和正常调用有什么区别？
| 对比维度       | 正常调用方法                                                                 | 反射调用方法                                                                 |
|----------------|------------------------------------------------------------------------------|------------------------------------------------------------------------------|
| 绑定时机       | 编译期确定方法（类、方法名、参数），直接生成字节码调用指令                   | 运行时动态获取Method对象，无法在编译期确认目标方法                           |
| 性能           | 快（无额外开销，JVM可优化）                                                 | 慢（需动态解析方法签名、安全检查、跳过部分JVM优化）                           |
| 代码可读性     | 直观（如`obj.method()`）                                                    | 繁琐（需获取Class、处理异常、调用`invoke()`）                                |
| 访问权限       | 受访问修饰符限制（private不可直接调用）                                      | 可突破权限（通过`setAccessible(true)`跳过访问检查）                          |

底层的本质区别——直接调用是“编译期定好路”，反射是“运行时找路”。直接调用时，编译器早就知道要调用哪个类的哪个方法、参数是什么类型，会把这些信息翻译成JVM能直接用的指令（比如指定方法入口地址），JVM还能提前做优化（比如把小方法“内联”到调用处），执行时一步到位，没有额外开销；

但反射不一样，它得等程序跑起来，先从Class对象里“查”出对应的Method（还要区分方法重载的参数类型），再做安全权限检查，最后才通过invoke()触发调用——相当于多走了“查地址、做校验”的弯路，底层步骤更多，所以天生比直接调用慢。

能不用反射就不用——反射不仅慢，还会让代码可读性变差（别人看代码时，不知道你到底要调用哪个方法）实在无法避免且是高频调用的情况下考虑用缓存Method优化。

---
### raft和zab的区别
Raft 和 Zab 的核心区别在于 **Leader 选举和日志一致性处理时机**。Raft 在选举阶段就保证新 leader 的日志是最新的，候选人只有日志最完整才能当选，这样一旦 leader 产生，日志天然连续，只需要追加即可。而 Zab 则是先选出 leader，再由 leader 与大多数节点比对、修复日志，保证一致性。

所以本质上，Raft 是 **“选举先裁剪，日志后追加”**，保证 leader 永远是日志最新节点，协议更直观易理解；Zab 是 **“选举先定，日志后同步”**，保证广播线性化和强一致性，但恢复时需要更多同步步骤。这个差别也导致 Raft 更适合通用分布式系统，而 Zab 主要优化 ZooKeeper 的事务和元数据管理场景。

---

### 感谢
感谢[Honesty](https://blog.hehouhui.cn/) 前辈的邮件回复，细腻地解答了1、2问的疑惑。