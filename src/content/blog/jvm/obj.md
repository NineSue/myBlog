---
title: 'JVM对象创建与内存'
author: '安'
description: 'JVM笔记整理'
publishDate: '2025-08-27'
updatedDate: '2025-08-27'
tags:
  - java
  - jvm
language: 'Chinese'
draft: false
heroImage: { src: './0.png', color: '#171618' }
---

首先来看一下JVM的内存布局，对于一个线程私有的是程序计数器、虚拟机栈、本地方法栈，线程共享的是堆、方法区(类信息，静态变量,运行时方法区)、直接内存。

## 创建对象

### step1
从一个对象创建的流程来看 JVM，当虚拟机遇到`new`指令时，首先去常量池查符号引用（类名、字段名、方法名）：
- 如果类已经加载、解析、初始化，就直接用。
- 如果没加载，就走类加载机制：加载 -> 验证 -> 准备 -> 解析 -> 初始化。

#### 类加载过程
1. **加载**：通过全类名定位类的二进制字节流，把它转化为方法区的运行时类数据，并映射出 Class 对象，建立 kv 快捷映射。
2. **验证**：确保字节流符合 JVM 规范，不会伤害 JVM，例如 class 文件格式、字节码语义、符号引用合法性。
3. **准备**：给类变量分配内存并设置默认零值（静态字段），JDK7 之前在永久代，7 之后在元空间或堆里。
4. **解析**：将符号引用映射为直接引用：
    - 方法 → 方法表 (vtable) 存实现地址
    - 字段 → 实例内偏移量
    - 类或接口 → 类指针
5. **初始化**：执行 `<clinit>`，静态字段和静态代码块生效。
6. **卸载**：没有实例引用 + 类加载器可回收，GC 才会回收类元信息。

### step2
类加载完成后，开始给新生对象分配内存，有两种方式：

- **指针碰撞**(Serial, ParNew)：堆规整时，用分配指针标界，已用/未用内存分开，偏移指针就完成分配。
- **空闲列表**(CMS)：维护空闲内存块数组，分配时更新记录。

线程安全分配：

- **TLAB (Thread Local Allocation Buffer)**：每个线程在 Eden 区预分配一块私有内存，先在 TLAB 分配对象。私有不需同步，效率高。
- **CAS + 失败重试**：TLAB 剩余内存不够时，用 CAS 在 Eden 堆分配，失败重试；若 TLAB 用完，再申请新 TLAB。

### step3
新生对象内存初始化零值，但不包括对象头。

### step4
设置对象头：记录对象是哪个类的实例、对象 hash、GC 年龄等信息。

### step5
执行 init 方法：实例初始化块、构造器、父类构造器调用。

### 对象内部布局
- **对象头**：标记字段 + 类型指针
- **实例数据**：父类 + 当前类字段
- **对齐填充**：保证对象大小是 8 字节倍数
